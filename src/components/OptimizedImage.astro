---
import type { OptimizedImageProps } from '../types/image';

interface Props extends Omit<OptimizedImageProps, 'onLoad' | 'onError'> {
  class?: string;
}

const {
  src,
  alt,
  width,
  height,
  class: className = '',
  loading = 'lazy',
  priority = false,
  sizes = '(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw',
  quality = 85,
  placeholder = 'empty',
  blurDataURL,
  style,
  responsive = true,
  srcSet,
  objectFit = 'cover',
  objectPosition = 'center',
  decoding = 'async',
  formats = [{ format: 'avif' }, { format: 'webp' }]
} = Astro.props;

// Generate responsive image paths
function generateSrcSet(baseSrc: string, widths: number[] = [480, 768, 1024, 1280, 1920]): string {
  if (srcSet) return srcSet;
  
  const basePath = baseSrc.replace(/\.[^/.]+$/, '');
  const extension = baseSrc.split('.').pop();
  
  return widths
    .map(w => `${basePath}-${w}w.${extension} ${w}w`)
    .join(', ');
}

function generateModernFormats(baseSrc: string) {
  const basePath = baseSrc.replace(/\.[^/.]+$/, '');
  return {
    avif: `${basePath}.avif`,
    webp: `${basePath}.webp`,
  };
}

const modernFormats = generateModernFormats(src);
const responsiveSrcSet = generateSrcSet(src);
const modernAvifSrcSet = generateSrcSet(modernFormats.avif);
const modernWebpSrcSet = generateSrcSet(modernFormats.webp);

// Generate unique ID for intersection observer
const imageId = `optimized-img-${Math.random().toString(36).substr(2, 9)}`;

// Inline styles for better performance
const containerStyles = {
  position: 'relative' as const,
  display: 'inline-block' as const,
  overflow: 'hidden' as const,
  ...(style || {}),
};

const imageStyles = {
  display: 'block' as const,
  maxWidth: '100%' as const,
  height: responsive ? 'auto' as const : '100%' as const,
  objectFit,
  objectPosition,
  transition: 'opacity 0.3s ease-in-out',
};
---

<div 
  id={imageId}
  class={`optimized-image-container ${className}`}
  style={containerStyles}
  data-loading={loading}
  data-priority={priority}
>
  <!-- Loading placeholder -->
  {placeholder === 'empty' && (
    <div class="image-placeholder">
      <div class="placeholder-animation"></div>
    </div>
  )}
  
  <!-- Blur placeholder -->
  {placeholder === 'blur' && blurDataURL && (
    <div class="blur-placeholder">
      <img 
        src={blurDataURL}
        alt=""
        aria-hidden="true"
        class="blur-image"
      />
    </div>
  )}

  <!-- Main responsive image -->
  <picture class="main-picture">
    <!-- Modern formats with responsive srcsets -->
    {formats.some(f => f.format === 'avif') && (
      <source 
        srcset={modernAvifSrcSet}
        type="image/avif"
        sizes={sizes}
      />
    )}
    
    {formats.some(f => f.format === 'webp') && (
      <source 
        srcset={modernWebpSrcSet}
        type="image/webp" 
        sizes={sizes}
      />
    )}
    
    <!-- Fallback image -->
    <img
      src={src}
      srcset={responsiveSrcSet}
      sizes={sizes}
      alt={alt}
      width={width}
      height={height}
      loading={priority ? 'eager' : loading}
      decoding={decoding}
      fetchpriority={priority ? 'high' : 'auto'}
      style={imageStyles}
      class="main-image"
    />
  </picture>
</div>

<style>
  .optimized-image-container {
    position: relative;
    display: inline-block;
    overflow: hidden;
  }

  .image-placeholder {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #f3f4f6;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: opacity 0.3s ease-in-out;
    pointer-events: none;
  }

  .placeholder-animation {
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
    background-size: 200% 100%;
    animation: loading 1.5s infinite;
    border-radius: 4px;
  }

  @keyframes loading {
    0% { background-position: 200% 0; }
    100% { background-position: -200% 0; }
  }

  .blur-placeholder {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    transition: opacity 0.3s ease-in-out;
    pointer-events: none;
  }

  .blur-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
    filter: blur(10px);
    transform: scale(1.1);
  }

  .main-picture {
    display: block;
    width: 100%;
  }

  .main-image {
    display: block;
    max-width: 100%;
    height: auto;
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
  }

  /* Show image when loaded */
  .main-image.loaded {
    opacity: 1;
  }

  /* Hide placeholders when image is loaded */
  .optimized-image-container.loaded .image-placeholder,
  .optimized-image-container.loaded .blur-placeholder {
    opacity: 0;
  }

  /* Error state */
  .optimized-image-container.error {
    background-color: #f3f4f6;
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 100px;
  }

  .optimized-image-container.error::after {
    content: 'Failed to load image';
    color: #9ca3af;
    font-size: 0.875rem;
  }

  /* Responsive optimizations */
  @media (max-width: 768px) {
    .optimized-image-container {
      max-width: 100vw;
    }
  }

  /* Reduce motion for accessibility */
  @media (prefers-reduced-motion: reduce) {
    .main-image,
    .image-placeholder,
    .blur-placeholder,
    .placeholder-animation {
      transition: none;
      animation: none;
    }
  }

  /* High contrast mode support */
  @media (prefers-contrast: high) {
    .image-placeholder {
      border: 2px solid currentColor;
    }
  }
</style>

<script>
  // Enhanced lazy loading with Intersection Observer
  class OptimizedImageLoader {
    private observer: IntersectionObserver;
    
    constructor() {
      this.observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              this.loadImage(entry.target as HTMLDivElement);
              this.observer.unobserve(entry.target);
            }
          });
        },
        {
          rootMargin: '50px',
          threshold: 0.01,
        }
      );
      
      this.init();
    }
    
    private init() {
      // Find all optimized image containers
      const containers = document.querySelectorAll('.optimized-image-container');
      
      containers.forEach((container) => {
        const isPriority = container.getAttribute('data-priority') === 'true';
        const loading = container.getAttribute('data-loading');
        
        if (isPriority || loading === 'eager') {
          this.loadImage(container as HTMLDivElement);
        } else {
          this.observer.observe(container);
        }
      });
    }
    
    private loadImage(container: HTMLDivElement) {
      const img = container.querySelector('.main-image') as HTMLImageElement;
      
      if (!img) return;
      
      const handleLoad = () => {
        container.classList.add('loaded');
        img.classList.add('loaded');
        img.removeEventListener('load', handleLoad);
        img.removeEventListener('error', handleError);
      };
      
      const handleError = () => {
        container.classList.add('error');
        img.removeEventListener('load', handleLoad);
        img.removeEventListener('error', handleError);
      };
      
      img.addEventListener('load', handleLoad);
      img.addEventListener('error', handleError);
      
      // If image is already loaded (cached)
      if (img.complete) {
        handleLoad();
      }
    }
    
    public destroy() {
      this.observer.disconnect();
    }
  }
  
  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      new OptimizedImageLoader();
    });
  } else {
    new OptimizedImageLoader();
  }
</script>