---
// Latent Labs-style protein visualization component with scroll-controlled video playback
// This component uses pre-rendered video frames for smooth 3D protein animations
---

<div class="protein-visualization-container">
  <div class="visualization-wrapper">
    <canvas id="protein-canvas" class="protein-canvas"></canvas>
    <div class="loading-overlay" id="loading-overlay">
      <div class="loading-spinner"></div>
      <p class="loading-text">Loading protein structure...</p>
    </div>
    <div class="visualization-info">
      <h3 class="protein-name">Antimicrobial Peptide LL-37</h3>
      <p class="protein-description">Human cathelicidin with broad-spectrum antimicrobial activity</p>
    </div>
  </div>
  <div class="scroll-indicator">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor">
      <path d="M12 5v14m0 0l-7-7m7 7l7-7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
    <span>Scroll to rotate</span>
  </div>
</div>

<script>
  class ProteinVisualization {
    constructor() {
      this.canvas = document.getElementById('protein-canvas') as HTMLCanvasElement;
      this.ctx = this.canvas.getContext('2d');
      this.loadingOverlay = document.getElementById('loading-overlay');
      
      // Configuration
      this.frameCount = 180; // Total number of frames (180 degrees rotation)
      this.currentFrame = 0;
      this.targetFrame = 0;
      this.frames = [];
      this.loadedFrames = 0;
      
      // Video/Image sequence configuration
      // In production, these would be actual video frames or image sequences
      this.frameBasePath = '/Portfolio/assets/protein-frames/'; // Path to frame images
      this.frameFormat = '.webp'; // Using WebP for better compression
      
      // Scroll configuration
      this.scrollSensitivity = 0.5;
      this.smoothingFactor = 0.1; // For smooth frame interpolation
      
      // Canvas sizing
      this.devicePixelRatio = window.devicePixelRatio || 1;
      
      this.init();
    }
    
    async init() {
      // Set canvas size
      this.resizeCanvas();
      window.addEventListener('resize', () => this.resizeCanvas());
      
      // Start loading frames
      await this.loadFrames();
      
      // Set up scroll listener
      this.setupScrollListener();
      
      // Start animation loop
      this.animate();
    }
    
    resizeCanvas() {
      const container = this.canvas.parentElement;
      const rect = container.getBoundingClientRect();
      
      // Set display size
      this.canvas.style.width = rect.width + 'px';
      this.canvas.style.height = rect.height + 'px';
      
      // Set actual size in memory (scaled for retina displays)
      this.canvas.width = rect.width * this.devicePixelRatio;
      this.canvas.height = rect.height * this.devicePixelRatio;
      
      // Scale context to ensure correct drawing operations
      this.ctx.scale(this.devicePixelRatio, this.devicePixelRatio);
    }
    
    async loadFrames() {
      // Create frame loading promises
      const framePromises = [];
      
      for (let i = 0; i < this.frameCount; i++) {
        const frameNumber = String(i).padStart(4, '0');
        const framePath = `${this.frameBasePath}frame_${frameNumber}${this.frameFormat}`;
        
        framePromises.push(this.loadFrame(framePath, i));
      }
      
      // Load all frames
      try {
        await Promise.all(framePromises);
        this.hideLoading();
      } catch (error) {
        console.error('Error loading frames:', error);
        // Fallback to generating synthetic frames
        this.generateSyntheticFrames();
        this.hideLoading();
      }
    }
    
    loadFrame(src, index) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
          this.frames[index] = img;
          this.loadedFrames++;
          
          // Update loading progress
          const progress = (this.loadedFrames / this.frameCount) * 100;
          this.updateLoadingProgress(progress);
          
          resolve(img);
        };
        img.onerror = () => reject(new Error(`Failed to load frame: ${src}`));
        img.src = src;
      });
    }
    
    // Fallback: Generate synthetic frames using canvas drawing
    generateSyntheticFrames() {
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = 800;
      tempCanvas.height = 600;
      const tempCtx = tempCanvas.getContext('2d');
      
      for (let i = 0; i < this.frameCount; i++) {
        // Clear canvas
        tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
        
        // Calculate rotation angle
        const angle = (i / this.frameCount) * Math.PI * 2;
        
        // Draw synthetic protein structure (simplified helix representation)
        this.drawSyntheticProtein(tempCtx, angle, tempCanvas.width / 2, tempCanvas.height / 2);
        
        // Convert canvas to image
        const img = new Image();
        img.src = tempCanvas.toDataURL();
        this.frames[i] = img;
      }
    }
    
    drawSyntheticProtein(ctx, angle, centerX, centerY) {
      ctx.save();
      ctx.translate(centerX, centerY);
      ctx.rotate(angle);
      
      // Draw helix-like structure
      const helixRadius = 100;
      const helixHeight = 200;
      const turns = 3;
      const pointsPerTurn = 20;
      const totalPoints = turns * pointsPerTurn;
      
      ctx.strokeStyle = '#DA291C';
      ctx.lineWidth = 3;
      ctx.beginPath();
      
      for (let i = 0; i <= totalPoints; i++) {
        const t = i / totalPoints;
        const theta = t * turns * 2 * Math.PI;
        const x = Math.cos(theta) * helixRadius;
        const y = (t - 0.5) * helixHeight;
        const z = Math.sin(theta) * helixRadius;
        
        // Simple 3D to 2D projection
        const scale = 1 + z / 200;
        const projX = x * scale;
        const projY = y * scale;
        
        if (i === 0) {
          ctx.moveTo(projX, projY);
        } else {
          ctx.lineTo(projX, projY);
        }
      }
      
      ctx.stroke();
      
      // Draw some spheres to represent atoms
      for (let i = 0; i < 10; i++) {
        const t = i / 9;
        const theta = t * turns * 2 * Math.PI;
        const x = Math.cos(theta) * helixRadius;
        const y = (t - 0.5) * helixHeight;
        const z = Math.sin(theta) * helixRadius;
        
        const scale = 1 + z / 200;
        const projX = x * scale;
        const projY = y * scale;
        const radius = 8 * scale;
        
        ctx.fillStyle = z > 0 ? '#FFD93D' : '#DA291C';
        ctx.beginPath();
        ctx.arc(projX, projY, radius, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.restore();
    }
    
    updateLoadingProgress(progress) {
      const loadingText = this.loadingOverlay.querySelector('.loading-text');
      if (loadingText) {
        loadingText.textContent = `Loading protein structure... ${Math.round(progress)}%`;
      }
    }
    
    hideLoading() {
      this.loadingOverlay.style.opacity = '0';
      setTimeout(() => {
        this.loadingOverlay.style.display = 'none';
      }, 300);
    }
    
    setupScrollListener() {
      let lastScrollY = window.scrollY;
      let scrollVelocity = 0;
      
      const handleScroll = () => {
        const scrollY = window.scrollY;
        const deltaY = scrollY - lastScrollY;
        
        // Calculate scroll velocity for momentum
        scrollVelocity = deltaY * this.scrollSensitivity;
        
        // Update target frame based on scroll
        this.targetFrame += scrollVelocity;
        
        // Clamp target frame
        this.targetFrame = Math.max(0, Math.min(this.frameCount - 1, this.targetFrame));
        
        lastScrollY = scrollY;
      };
      
      // Throttle scroll events for performance
      let scrollTimeout;
      window.addEventListener('scroll', () => {
        if (scrollTimeout) return;
        
        scrollTimeout = setTimeout(() => {
          handleScroll();
          scrollTimeout = null;
        }, 16); // ~60fps
      });
      
      // Also handle wheel events for more precise control
      this.canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        this.targetFrame += e.deltaY * 0.1;
        this.targetFrame = Math.max(0, Math.min(this.frameCount - 1, this.targetFrame));
      });
    }
    
    animate() {
      // Smooth interpolation between current and target frame
      this.currentFrame += (this.targetFrame - this.currentFrame) * this.smoothingFactor;
      
      // Get the frame to display
      const frameIndex = Math.round(this.currentFrame) % this.frameCount;
      const frame = this.frames[frameIndex];
      
      if (frame && frame.complete) {
        // Clear canvas
        const displayWidth = this.canvas.style.width.replace('px', '');
        const displayHeight = this.canvas.style.height.replace('px', '');
        this.ctx.clearRect(0, 0, displayWidth, displayHeight);
        
        // Calculate aspect ratio preserving dimensions
        const scale = Math.min(
          displayWidth / frame.width,
          displayHeight / frame.height
        );
        
        const x = (displayWidth - frame.width * scale) / 2;
        const y = (displayHeight - frame.height * scale) / 2;
        
        // Draw frame
        this.ctx.drawImage(
          frame,
          x, y,
          frame.width * scale,
          frame.height * scale
        );
      }
      
      // Continue animation loop
      requestAnimationFrame(() => this.animate());
    }
  }
  
  // Initialize visualization when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    new ProteinVisualization();
  });
</script>

<style>
  .protein-visualization-container {
    position: relative;
    width: 100%;
    margin: var(--space-xl) 0;
  }
  
  .visualization-wrapper {
    position: relative;
    width: 100%;
    height: 60vh;
    min-height: 400px;
    max-height: 800px;
    background: var(--background-alt);
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    border: 1px solid var(--border);
  }
  
  .protein-canvas {
    width: 100%;
    height: 100%;
    display: block;
    cursor: grab;
  }
  
  .protein-canvas:active {
    cursor: grabbing;
  }
  
  .loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--background);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    transition: opacity 0.3s ease;
    z-index: 10;
  }
  
  .loading-spinner {
    width: 48px;
    height: 48px;
    border: 3px solid var(--border);
    border-top-color: var(--accent-red);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: var(--space-md);
  }
  
  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }
  
  .loading-text {
    color: var(--secondary);
    font-size: 0.9rem;
  }
  
  .visualization-info {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    padding: var(--space-lg);
    background: linear-gradient(to top, var(--background) 0%, transparent 100%);
    pointer-events: none;
  }
  
  .protein-name {
    font-size: 1.5rem;
    font-weight: var(--font-weight-light);
    margin-bottom: var(--space-xs);
    color: var(--primary);
  }
  
  .protein-description {
    font-size: 0.95rem;
    color: var(--secondary);
    max-width: 600px;
  }
  
  .scroll-indicator {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-sm);
    margin-top: var(--space-md);
    color: var(--secondary);
    font-size: 0.9rem;
    opacity: 0.7;
    transition: opacity 0.3s ease;
  }
  
  .scroll-indicator:hover {
    opacity: 1;
  }
  
  .scroll-indicator svg {
    animation: bounce 2s ease-in-out infinite;
  }
  
  @keyframes bounce {
    0%, 20%, 50%, 80%, 100% {
      transform: translateY(0);
    }
    40% {
      transform: translateY(4px);
    }
    60% {
      transform: translateY(2px);
    }
  }
  
  /* Responsive adjustments */
  @media (max-width: 768px) {
    .visualization-wrapper {
      height: 50vh;
      min-height: 300px;
    }
    
    .visualization-info {
      padding: var(--space-md);
    }
    
    .protein-name {
      font-size: 1.2rem;
    }
    
    .protein-description {
      font-size: 0.85rem;
    }
  }
  
  /* Dark mode adjustments */
  @media (prefers-color-scheme: dark) {
    .visualization-wrapper {
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }
    
    .loading-overlay {
      background: var(--background);
    }
  }
</style>