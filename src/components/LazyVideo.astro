---
interface Props {
  src: string;
  poster?: string;
  alt?: string;
  autoplay?: boolean;
  muted?: boolean;
  loop?: boolean;
  controls?: boolean;
  className?: string;
  width?: number;
  height?: number;
  priority?: boolean; // For above-the-fold videos
}

const {
  src,
  poster,
  alt = '',
  autoplay = false,
  muted = true,
  loop = true,
  controls = false,
  className = '',
  width,
  height,
  priority = false
} = Astro.props;

// Generate responsive video sources
const videoId = src.split('/').pop()?.replace(/\.[^/.]+$/, '') || 'video';
const basePath = src.replace(/\/[^/]+$/, '');
---

<div class={`lazy-video-container ${className}`} data-video-id={videoId}>
  <!-- Poster image as immediate content -->
  {poster && (
    <img 
      src={poster}
      alt={alt}
      width={width}
      height={height}
      loading={priority ? "eager" : "lazy"}
      decoding="async"
      class="video-poster"
    />
  )}
  
  <!-- Play button overlay -->
  <button 
    class="video-play-button"
    aria-label="Play video"
    data-video-trigger={videoId}
    type="button"
  >
    <svg width="68" height="48" viewBox="0 0 68 48" fill="none" aria-hidden="true">
      <path d="M66.52,7.74c-0.78-2.93-2.49-5.41-5.42-6.19C55.79,.13,34,0,34,0S12.21,.13,6.9,1.55 C3.97,2.33,2.27,4.81,1.48,7.74C0.06,13.05,0,24,0,24s0.06,10.95,1.48,16.26c0.78,2.93,2.49,5.41,5.42,6.19 C12.21,47.87,34,48,34,48s21.79-0.13,27.1-1.55c2.93-0.78,4.64-3.26,5.42-6.19C67.94,34.95,68,24,68,24S67.94,13.05,66.52,7.74z" fill="#f00"></path>
      <path d="M45,24L27,14v20" fill="#fff"></path>
    </svg>
    <span class="sr-only">Play {alt || 'video'}</span>
  </button>
  
  <!-- Video element (loaded on demand) -->
  <video
    data-src={src}
    poster={poster}
    muted={muted}
    loop={loop}
    playsinline
    controls={controls}
    width={width}
    height={height}
    preload="none"
    class="lazy-video hidden"
    data-video={videoId}
    aria-label={alt}
    {autoplay && muted ? { autoplay: true } : {}}
  />
  
  <!-- Loading state -->
  <div class="video-loading hidden" data-loading={videoId}>
    <div class="loading-spinner"></div>
    <span>Loading video...</span>
  </div>
</div>

<script>
  class LazyVideoLoader {
    private intersectionObserver: IntersectionObserver | null = null;
    private loadedVideos = new Set<string>();

    constructor() {
      this.init();
    }

    private init() {
      // Set up intersection observer for auto-loading near viewport
      if ('IntersectionObserver' in window) {
        this.intersectionObserver = new IntersectionObserver(
          this.handleIntersection.bind(this),
          { rootMargin: '100px 0px' }
        );

        // Observe all video containers
        document.querySelectorAll('.lazy-video-container').forEach(container => {
          if (container instanceof HTMLElement) {
            this.intersectionObserver?.observe(container);
          }
        });
      }

      // Set up click handlers for play buttons
      this.setupClickHandlers();
    }

    private handleIntersection(entries: IntersectionObserverEntry[]) {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const container = entry.target as HTMLElement;
          const videoId = container.dataset.videoId;
          if (videoId && !this.loadedVideos.has(videoId)) {
            // For auto-playing background videos, load immediately when in view
            const video = container.querySelector(`[data-video="${videoId}"]`) as HTMLVideoElement;
            if (video?.dataset.src && video.hasAttribute('autoplay')) {
              this.loadVideo(videoId);
            }
          }
        }
      });
    }

    private setupClickHandlers() {
      document.addEventListener('click', (e) => {
        const target = e.target as HTMLElement;
        const playButton = target.closest('[data-video-trigger]') as HTMLElement;
        
        if (playButton) {
          e.preventDefault();
          const videoId = playButton.dataset.videoTrigger;
          if (videoId) {
            this.loadAndPlayVideo(videoId);
          }
        }
      });
    }

    private async loadVideo(videoId: string): Promise<HTMLVideoElement | null> {
      if (this.loadedVideos.has(videoId)) {
        return document.querySelector(`[data-video="${videoId}"]`) as HTMLVideoElement;
      }

      const container = document.querySelector(`[data-video-id="${videoId}"]`) as HTMLElement;
      if (!container) return null;

      const video = container.querySelector(`[data-video="${videoId}"]`) as HTMLVideoElement;
      const loading = container.querySelector(`[data-loading="${videoId}"]`) as HTMLElement;
      const poster = container.querySelector('.video-poster') as HTMLImageElement;

      if (!video) return null;

      // Show loading state
      loading?.classList.remove('hidden');
      
      try {
        // Load video source
        const src = video.dataset.src;
        if (src) {
          video.src = src;
          video.load();

          return new Promise((resolve, reject) => {
            const handleLoad = () => {
              this.loadedVideos.add(videoId);
              video.classList.remove('hidden');
              loading?.classList.add('hidden');
              
              // Hide poster if video is ready to play
              if (poster) {
                poster.style.opacity = '0';
                setTimeout(() => poster.style.display = 'none', 300);
              }
              
              resolve(video);
            };

            const handleError = () => {
              loading?.classList.add('hidden');
              console.warn(`Failed to load video: ${videoId}`);
              reject(new Error(`Video load failed: ${videoId}`));
            };

            video.addEventListener('loadeddata', handleLoad, { once: true });
            video.addEventListener('error', handleError, { once: true });
            
            // Timeout after 10 seconds
            setTimeout(() => {
              if (!this.loadedVideos.has(videoId)) {
                handleError();
              }
            }, 10000);
          });
        }
      } catch (error) {
        loading?.classList.add('hidden');
        console.warn('Video loading error:', error);
      }

      return null;
    }

    private async loadAndPlayVideo(videoId: string) {
      try {
        const video = await this.loadVideo(videoId);
        if (video) {
          // Hide play button
          const playButton = document.querySelector(`[data-video-trigger="${videoId}"]`) as HTMLElement;
          if (playButton) {
            playButton.style.display = 'none';
          }

          // Play video
          await video.play();
          
          // Track interaction for analytics
          if ((window as any).gtag) {
            (window as any).gtag('event', 'video_start', {
              video_title: videoId,
              video_current_time: 0
            });
          }
        }
      } catch (error) {
        console.warn('Error playing video:', error);
      }
    }

    public destroy() {
      this.intersectionObserver?.disconnect();
      this.loadedVideos.clear();
    }
  }

  // Initialize lazy video loader when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => new LazyVideoLoader());
  } else {
    new LazyVideoLoader();
  }
</script>

<style>
  .lazy-video-container {
    position: relative;
    width: 100%;
    height: 100%;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #000;
  }

  .video-poster {
    width: 100%;
    height: 100%;
    object-fit: cover;
    transition: opacity 0.3s ease;
  }

  .lazy-video {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .lazy-video.hidden {
    display: none;
  }

  .video-play-button {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: transparent;
    border: none;
    cursor: pointer;
    z-index: 10;
    transition: transform 0.2s ease;
    padding: 0;
  }

  .video-play-button:hover {
    transform: translate(-50%, -50%) scale(1.1);
  }

  .video-play-button:focus-visible {
    outline: 3px solid rgba(255, 255, 255, 0.8);
    outline-offset: 4px;
    border-radius: 4px;
  }

  .video-loading {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
    color: white;
    font-size: 0.9rem;
    z-index: 5;
  }

  .video-loading.hidden {
    display: none;
  }

  .loading-spinner {
    width: 40px;
    height: 40px;
    border: 3px solid rgba(255, 255, 255, 0.3);
    border-top: 3px solid white;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  @media (prefers-reduced-motion: reduce) {
    .video-play-button,
    .loading-spinner,
    .video-poster {
      animation: none !important;
      transition: none !important;
    }
  }

  /* Connection-aware loading */
  @media (max-width: 768px) {
    .video-play-button svg {
      width: 48px;
      height: 36px;
    }
  }
</style>