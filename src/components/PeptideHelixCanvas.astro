---
export interface Props {
  className?: string;
}

const { className = '' } = Astro.props;
---

<div class={`peptide-canvas-container ${className}`}>
  <canvas id="peptide-helix-canvas" aria-label="Interactive peptide helix visualization"></canvas>
</div>

<script>
  const canvas = document.getElementById('peptide-helix-canvas') as HTMLCanvasElement;
  const ctx = canvas.getContext('2d');
  
  if (ctx) {
    // Set canvas size
    const resizeCanvas = () => {
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;
    };
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // Alpha helix parameters (scientifically accurate)
    const RESIDUES_PER_TURN = 3.6;
    const PITCH = 5.4; // Angstroms
    const HELIX_RADIUS = 2.3; // Angstroms
    const SCALE = 40; // Pixels per Angstrom
    
    // Amino acid structure
    interface Residue {
      x: number;
      y: number;
      z: number;
      angle: number;
      alpha: number; // Alpha carbon
      carbonyl: { x: number; y: number; z: number }; // C=O
      nitrogen: { x: number; y: number; z: number }; // N-H
      sidechain: { x: number; y: number; z: number }; // R group
    }
    
    const residues: Residue[] = [];
    const NUM_RESIDUES = 20;
    
    // Generate helix coordinates
    for (let i = 0; i < NUM_RESIDUES; i++) {
      const angle = (i * 2 * Math.PI) / RESIDUES_PER_TURN;
      const height = (i * PITCH) / RESIDUES_PER_TURN;
      
      const residue: Residue = {
        x: HELIX_RADIUS * Math.cos(angle),
        y: height,
        z: HELIX_RADIUS * Math.sin(angle),
        angle: angle,
        alpha: 1.0,
        carbonyl: {
          x: HELIX_RADIUS * Math.cos(angle) - 0.8 * Math.cos(angle + Math.PI/4),
          y: height - 0.3,
          z: HELIX_RADIUS * Math.sin(angle) - 0.8 * Math.sin(angle + Math.PI/4)
        },
        nitrogen: {
          x: HELIX_RADIUS * Math.cos(angle) + 0.8 * Math.cos(angle - Math.PI/4),
          y: height + 0.3,
          z: HELIX_RADIUS * Math.sin(angle) + 0.8 * Math.sin(angle - Math.PI/4)
        },
        sidechain: {
          x: HELIX_RADIUS * 1.5 * Math.cos(angle),
          y: height,
          z: HELIX_RADIUS * 1.5 * Math.sin(angle)
        }
      };
      
      residues.push(residue);
    }
    
    // Carbon drawing style
    const drawCarbonStyle = (ctx: CanvasRenderingContext2D) => {
      ctx.strokeStyle = '#2a2a2a';
      ctx.fillStyle = '#1a1a1a';
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.8;
      
      // Add sketchy effect
      ctx.shadowBlur = 1;
      ctx.shadowColor = '#666';
      ctx.shadowOffsetX = 0.5;
      ctx.shadowOffsetY = 0.5;
    };
    
    // Draw peptide bond
    const drawPeptideBond = (ctx: CanvasRenderingContext2D, r1: Residue, r2: Residue, centerX: number, centerY: number) => {
      const x1 = centerX + r1.x * SCALE;
      const y1 = centerY + r1.y * SCALE;
      const x2 = centerX + r2.x * SCALE;
      const y2 = centerY + r2.y * SCALE;
      
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    };
    
    // Draw atom
    const drawAtom = (ctx: CanvasRenderingContext2D, x: number, y: number, radius: number, opacity: number = 0.8) => {
      ctx.globalAlpha = opacity;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fill();
      
      // Add pencil texture
      for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.arc(x + Math.random() * 2 - 1, y + Math.random() * 2 - 1, radius * 0.9, 0, Math.PI * 2);
        ctx.stroke();
      }
    };
    
    // Draw hydrogen bond
    const drawHydrogenBond = (ctx: CanvasRenderingContext2D, r1: Residue, r2: Residue, centerX: number, centerY: number) => {
      const x1 = centerX + r1.nitrogen.x * SCALE;
      const y1 = centerY + r1.nitrogen.y * SCALE;
      const x2 = centerX + r2.carbonyl.x * SCALE;
      const y2 = centerY + r2.carbonyl.y * SCALE;
      
      ctx.strokeStyle = '#666';
      ctx.lineWidth = 1;
      ctx.setLineDash([3, 3]);
      ctx.globalAlpha = 0.3;
      
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
      
      ctx.setLineDash([]);
    };
    
    let rotation = 0;
    
    // Animation loop
    const animate = () => {
      if (!ctx) return;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw graph paper background
      ctx.strokeStyle = '#f0f0f0';
      ctx.lineWidth = 0.5;
      ctx.globalAlpha = 0.1;
      
      for (let x = 0; x < canvas.width; x += 20) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      
      for (let y = 0; y < canvas.height; y += 20) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }
      
      drawCarbonStyle(ctx);
      
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2 - 100;
      
      // Sort residues by z-coordinate for proper depth rendering
      const sortedResidues = [...residues].sort((a, b) => a.z - b.z);
      
      // Draw backbone
      ctx.globalAlpha = 0.4;
      ctx.beginPath();
      sortedResidues.forEach((residue, i) => {
        const x = centerX + residue.x * SCALE * Math.cos(rotation) - residue.z * SCALE * Math.sin(rotation);
        const y = centerY + residue.y * SCALE;
        
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.stroke();
      
      // Draw hydrogen bonds
      for (let i = 0; i < residues.length - 4; i++) {
        drawHydrogenBond(ctx, residues[i], residues[i + 4], centerX, centerY);
      }
      
      // Draw residues
      sortedResidues.forEach((residue, i) => {
        const x = centerX + residue.x * SCALE * Math.cos(rotation) - residue.z * SCALE * Math.sin(rotation);
        const y = centerY + residue.y * SCALE;
        const z = residue.x * SCALE * Math.sin(rotation) + residue.z * SCALE * Math.cos(rotation);
        
        // Calculate opacity based on z-depth
        const depthOpacity = 0.5 + (z / (HELIX_RADIUS * SCALE * 2)) * 0.5;
        
        // Draw alpha carbon
        drawAtom(ctx, x, y, 8, depthOpacity * 0.8);
        
        // Draw carbonyl group
        const cX = centerX + residue.carbonyl.x * SCALE * Math.cos(rotation) - residue.carbonyl.z * SCALE * Math.sin(rotation);
        const cY = centerY + residue.carbonyl.y * SCALE;
        ctx.strokeStyle = '#333';
        ctx.globalAlpha = depthOpacity * 0.6;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(cX, cY);
        ctx.stroke();
        drawAtom(ctx, cX, cY, 5, depthOpacity * 0.5);
        
        // Draw nitrogen
        const nX = centerX + residue.nitrogen.x * SCALE * Math.cos(rotation) - residue.nitrogen.z * SCALE * Math.sin(rotation);
        const nY = centerY + residue.nitrogen.y * SCALE;
        ctx.strokeStyle = '#333';
        ctx.globalAlpha = depthOpacity * 0.6;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(nX, nY);
        ctx.stroke();
        drawAtom(ctx, nX, nY, 6, depthOpacity * 0.6);
        
        // Draw side chain
        const sX = centerX + residue.sidechain.x * SCALE * Math.cos(rotation) - residue.sidechain.z * SCALE * Math.sin(rotation);
        const sY = centerY + residue.sidechain.y * SCALE;
        ctx.strokeStyle = '#4a4a4a';
        ctx.globalAlpha = depthOpacity * 0.4;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(sX, sY);
        ctx.stroke();
        drawAtom(ctx, sX, sY, 4, depthOpacity * 0.4);
      });
      
      // Draw annotations
      ctx.fillStyle = '#4a4a4a';
      ctx.font = '14px "Courier New", monospace';
      ctx.globalAlpha = 0.6;
      ctx.fillText('α-helix', 50, 50);
      ctx.font = '12px "Courier New", monospace';
      ctx.globalAlpha = 0.5;
      ctx.fillText('3.6 residues/turn', 50, 70);
      ctx.fillText('5.4 Å pitch', 50, 90);
      
      // Slow rotation
      rotation += 0.005;
      
      requestAnimationFrame(animate);
    };
    
    animate();
  }
</script>

<style>
  .peptide-canvas-container {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }
  
  #peptide-helix-canvas {
    width: 100%;
    height: 100%;
    opacity: 0.2;
  }
  
  @media (prefers-reduced-motion: reduce) {
    #peptide-helix-canvas {
      display: none;
    }
  }
</style>