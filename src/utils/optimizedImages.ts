/**
 * Optimized Image Components and Utilities
 * Generated by optimize-images.mjs
 */

export interface ImageVariant {
  src: string;
  width: number;
  height: number;
  format: string;
  size?: string; // CSS size hint
}

export interface OptimizedImageConfig {
  variants: ImageVariant[];
  alt: string;
  loading?: 'lazy' | 'eager';
  decoding?: 'async' | 'sync';
  className?: string;
}

// Profile image variants
export const PROFILE_IMAGE_VARIANTS: ImageVariant[] = [
  // AVIF variants (best compression)
  { src: '/Portfolio/profile@2x.avif', width: 240, height: 240, format: 'avif', size: '120px' },
  { src: '/Portfolio/profile.avif', width: 120, height: 120, format: 'avif', size: '120px' },
  { src: '/Portfolio/profile@0.5x.avif', width: 60, height: 60, format: 'avif', size: '60px' },
  
  // WebP variants (good compression, wider support)
  { src: '/Portfolio/profile@2x.webp', width: 240, height: 240, format: 'webp', size: '120px' },
  { src: '/Portfolio/profile.webp', width: 120, height: 120, format: 'webp', size: '120px' },
  { src: '/Portfolio/profile@0.5x.webp', width: 60, height: 60, format: 'webp', size: '60px' },
  
  // JPEG fallback
  { src: '/Portfolio/profile@2x.jpg', width: 240, height: 240, format: 'jpg', size: '120px' },
  { src: '/Portfolio/profile.jpg', width: 120, height: 120, format: 'jpg', size: '120px' },
  { src: '/Portfolio/profile@0.5x.jpg', width: 60, height: 60, format: 'jpg', size: '60px' }
];

// Video poster variants
export const VIDEO_POSTER_VARIANTS: ImageVariant[] = [
  // AVIF variants
  { src: '/Portfolio/hero/video-poster@2x.avif', width: 1920, height: 1080, format: 'avif' },
  { src: '/Portfolio/hero/video-poster.avif', width: 960, height: 540, format: 'avif' },
  { src: '/Portfolio/hero/video-poster@0.5x.avif', width: 480, height: 270, format: 'avif' },
  
  // WebP variants  
  { src: '/Portfolio/hero/video-poster@2x.webp', width: 1920, height: 1080, format: 'webp' },
  { src: '/Portfolio/hero/video-poster.webp', width: 960, height: 540, format: 'webp' },
  { src: '/Portfolio/hero/video-poster@0.5x.webp', width: 480, height: 270, format: 'webp' }
];

/**
 * Generate responsive picture element HTML
 */
export function generatePictureElement(variants: ImageVariant[], config: OptimizedImageConfig): string {
  const { alt, loading = 'lazy', decoding = 'async', className = '' } = config;
  
  // Group by format for source elements
  const formatGroups = variants.reduce((groups, variant) => {
    if (!groups[variant.format]) groups[variant.format] = [];
    groups[variant.format].push(variant);
    return groups;
  }, {} as Record<string, ImageVariant[]>);

  let sources = '';
  
  // AVIF first (best compression)
  if (formatGroups.avif) {
    const srcset = formatGroups.avif.map(v => 
      `${v.src} ${v.width}w`
    ).join(', ');
    sources += `<source srcset="${srcset}" type="image/avif" />`;
  }
  
  // WebP second (good compression)
  if (formatGroups.webp) {
    const srcset = formatGroups.webp.map(v => 
      `${v.src} ${v.width}w`
    ).join(', ');
    sources += `<source srcset="${srcset}" type="image/webp" />`;
  }
  
  // JPEG fallback
  const jpegVariants = formatGroups.jpg || [];
  const fallbackSrc = jpegVariants.find(v => v.width === 120)?.src || variants[0].src;
  
  return `
    <picture class="${className}">
      ${sources}
      <img 
        src="${fallbackSrc}" 
        alt="${alt}"
        loading="${loading}"
        decoding="${decoding}"
        width="120" 
        height="120"
      />
    </picture>
  `.trim();
}

/**
 * Generate optimized image HTML string
 */
export function OptimizedImage({ variants, alt, loading = 'lazy', className = '' }: OptimizedImageConfig & { alt: string; loading?: string; className?: string }) {
  const formatGroups = variants.reduce((groups, variant) => {
    if (!groups[variant.format]) groups[variant.format] = [];
    groups[variant.format].push(variant);
    return groups;
  }, {} as Record<string, ImageVariant[]>);

  const sources = [];
  
  if (formatGroups.avif) {
    const srcSet = formatGroups.avif.map(v => `${v.src} ${v.width}w`).join(', ');
    sources.push(`<source srcset="${srcSet}" type="image/avif" />`);
  }
  
  if (formatGroups.webp) {
    const srcSet = formatGroups.webp.map(v => `${v.src} ${v.width}w`).join(', ');
    sources.push(`<source srcset="${srcSet}" type="image/webp" />`);
  }
  
  const fallbackSrc = formatGroups.jpg?.[0]?.src || variants[0].src;
  
  return `
    <picture class="${className}">
      ${sources.join('\n      ')}
      <img 
        src="${fallbackSrc}" 
        alt="${alt}"
        loading="${loading}"
        decoding="async"
        width="120" 
        height="120"
      />
    </picture>
  `.trim();
}