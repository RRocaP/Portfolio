// Advanced TypeScript patterns implementation
// 1. Branded types
export type Brand<K, T> = K & { readonly __brand: T };
export type UUID = Brand<string, 'uuid'>;
export function asUUID(v: string): UUID { if(!/^[0-9a-fA-F-]{36}$/.test(v)) throw new Error('Invalid UUID'); return v as UUID; }

// 2. Template literal types for i18n keys (autogenerated from translations object keys)
import { translations } from '../data/i18n';

type NestedKeys<T, Prefix extends string = ''> = T extends object ? {
  [K in keyof T & string]: T[K] extends object ? NestedKeys<T[K], `${Prefix}${K}.`> : `${Prefix}${K}`
}[keyof T & string] : never;

export type I18nKey = NestedKeys<typeof translations['en']>; // use English shape as base

// 3. Conditional types for component props
export interface BaseComponentProps { variant?: 'compact' | 'detailed'; }
export type VariantProps<V> = V extends { variant: 'compact' } ? { maxItems?: number } : V extends { variant: 'detailed' } ? { showMeta?: boolean } : {};
export type ComponentProps<V extends BaseComponentProps> = V & VariantProps<V>;

// 4. Discriminated unions for research categories
export type ResearchCategory =
  | { kind: 'vector'; subtype: 'AAV' | 'Lentiviral'; focus: 'tropism' | 'payload' }
  | { kind: 'protein'; subtype: 'antimicrobial' | 'enzyme'; focus: 'stability' | 'activity' }
  | { kind: 'delivery'; subtype: 'nanoparticle' | 'biomaterial'; focus: 'targeting' | 'release' };

export function categoryLabel(cat: ResearchCategory): string {
  switch(cat.kind) {
    case 'vector': return `Vector/${cat.subtype} (${cat.focus})`;
    case 'protein': return `Protein/${cat.subtype} (${cat.focus})`;
    case 'delivery': return `Delivery/${cat.subtype} (${cat.focus})`;
  }
}

// 5. Advanced generics for data fetching with runtime validator pass-through
export interface FetchConfig<TIn, TOut extends TIn = TIn> {
  endpoint: string;
  map?: (raw: TIn) => TOut;
  validate?: (raw: unknown) => raw is TIn;
  cache?: boolean;
}

const _fetchCache = new Map<string, unknown>();

export async function typedFetch<TIn, TOut extends TIn = TIn>(cfg: FetchConfig<TIn, TOut>): Promise<TOut> {
  if(cfg.cache && _fetchCache.has(cfg.endpoint)) return _fetchCache.get(cfg.endpoint) as TOut;
  const res = await fetch(cfg.endpoint);
  const json = await res.json();
  if(cfg.validate && !cfg.validate(json)) throw new Error('Validation failed');
  const mapped = cfg.map ? cfg.map(json) : json as TOut;
  if(cfg.cache) _fetchCache.set(cfg.endpoint, mapped);
  return mapped;
}

// Utility: narrow array of categories by predicate with inference
export function filterCategories<C extends ResearchCategory, K extends C['kind']>(list: C[], kind: K): Extract<C, { kind: K }>[] {
  return list.filter(c => c.kind === kind) as any;
}
